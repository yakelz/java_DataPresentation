package Set;
import java.util.Arrays;

public class ArraySet {
    int x; // Левая граница
    int y; // Права граница
    int[] array; // Массив

    // Класс позиции
    private class Position{
        int index; // Адрес в массиве
        int bit; // Номер бита
        Position (int index, int bit) {
            this.index = index;
            this.bit = bit;
        }
    }

    //default конструктор
    public ArraySet(int x, int y) {
        this.x = x;
        this.y = y;
        // Если y < x, тогда ошибка
        if (y < x) {
            throw new RuntimeException("ArraySet(): не правильно указаны границы");
        }
        // Инициализация массива
        // (y - x) / 32 + 1   -  длина массива
        array = new int[(y - x) / 32 + 1];
    }

    // Нахождение нужной ячейки массива
    private Position findInArray(int value) {
        // Получаем номер бита
        int bitNumber = value - x;
        // Нужная позиция это индекс в массиве (номер бита /32) и номер бита в массиве (остаток от деления)
        return new Position(bitNumber/32, bitNumber%32);
    }

    // Возвращает множество в котором есть все неповторяющиеся элементы
    public ArraySet Union (ArraySet input) {
        // Если input это тоже самое множество - return

        // Вычисляем min от Х, и max от У
        // Создаем новый массив c новыми границами

        // Находим относительное смещение первого массива (относительно нового массива)
        // И Копируем ЯЧЕЙКИ первого массива в новый массив

        // Находим относительное смещение второго массива (относительно нового массива)
        // новый массив побитово умножаем на элементы второго массива (учитывая смещение)
        return null;
    }

    //Возвращает множество общих элементов
    public ArraySet Intersection(ArraySet input){
        // Если input это тоже самое множество - возвращаем исходный

        // Проверяем пересечения границ
            // если конец 1 < старт 2 ИЛИ конец 2 < старт 1
        // Если пересечений границ нет - возвращаем пустой массив

        // Вычисляем min от У, и max от X
        // Создаем новый массив c новыми границами

        // Находим относительное смещение первого массива (относительно нового массива)
        // Копируем все ЯЧЕЙКИ первого массива в новый массив
            // ( со смещением от Х )

        // Находим относительное смещение второго массива (относительно нового массива)
        // новый массив побитово умножаем на элементы второго массива (учитывая смещение)
            // ( со смещением от Х )
        return null;
    }

    //Возвращает множество с элементами которых нет в исходном множестве
    public ArraySet Difference (ArraySet input) {
        // Если input это тоже самое множество - return

        //Проверка на пересечение
            // если конец 1 < старт 2 ИЛИ конец 2 < старт 1
        // Если множетсва не пересекаются, возвращаем input

        //Если пересекаются:
        // Создаем новый массив c границами как у input

        // Находим относительное смещение первого массива (относительно нового массива)
        // Копируем все ЯЧЕЙКИ первого массива в новый массив

        // Чтобы найти биты, которых нет в input
        // Инвертируем биты исходного массива и умножаем на биты Input
        return null;
    }

    // Возвращает множество с которым есть все неповторяющиеся элементы
    // Только если множества не пересекаются
    public ArraySet Merge(ArraySet input){
        // Если input это тоже самое множество - возвращаем исходный

        //Проверка на пересечение границ
            // если конец 1 < старт 2 ИЛИ конец 2 < старт 1

                //Если они пересекаются тогда проверка всех битов массивов
                    // Вычисляем min от У, и max от X
                    // Вычисляем длину массива: (max - min) / 32 + 1
                    // Находим относительное смещение первого массива
                    // Находим относительное смещение второго массива
                    // Побитово умножаем бит первого массива на второй
                        // Если == 0 - тогда значит есть пересечения битов => return

        // Вычисляем min от Х, и max от У
        // Создаем новый массив c новыми границами

        // Находим относительное смещение первого массива (относительно нового массива)
        // И Копируем ЯЧЕЙКИ первого массива в новый массив

        // Находим относительное смещение второго массива (относительно нового массива)
        // И Копируем ЯЧЕЙКИ второго массива в новый массив


        return null;
    }

    // Возвращает true - если value есть в множестве
    // false - если его нет
    public boolean Member(int value){
        // Проверить выход за границы
            // value < x || value > y
        // Найти нужную ячейку массива
        // Вычислить и вставить нужный бит, и побитовым И сравнить c ячейкой
        // Если ячейка != 0 - true
        return false;
    }

    // При вставке и удалении не изменяется диапазон

    // Вставка значения в множество
    public void Insert(int value){
        // Проверить выход за границы
            // value < x || value > y
        // Найти нужную ячейку массива
        Position position = findInArray(x);
        // Вычислить и вставить нужный бит, побитовым ИЛИ
        array[position.index] |= 1 << 31 - position.bit;
    }

    // Удаление элемента из множества
    // Если элемента нет - выход.
    public void Delete(int value){
        // Проверить выход за границы
            // value < x || value > y
        // Найти нужную ячейку массива
        Position position = findInArray(x);
        // Вычислить и вставить нужный бит, и побитовым И с ИНВЕРСИЕЙ сравнить с ячейкой
        array[position.index] &= ~(1 << 31 - position.bit);
    }

    // Присваивание нового множества
    public void Assign(ArraySet input){
        // Копирующий метод
        this.x = input.x;
        this.y = input.y;
        this.array = new int[input.array.length];
        for (int i = 0; i < array.length; i++) {
            this.array[i] = input.array[i];
        }
    }

    // Возвращает минимальное значение в множестве
    public int Min(){
        // Найти самый левый бит с 1
        // и вычислить его значение
        return 0;
    }

    // Возвращает максимальное значение в множестве
    public int Max(){
        // Найти самый правый бит с 1
        // и вычислить его значение
        return 0;
    }

    // Возвращает true - если множества одинаковые.
    public boolean Equal(){
        // Сравнить диапазоны, если они разные - выход
        // Побитово И - сравнить каждое множество и если результат одинаковый - true
        return false;
    }

    // Возвращает множество, где найдет X
    // A и B - непересекающиеся множества
    // Если нет такого элемента, возвращаем пустое множество.
    public ArraySet Find(ArraySet input, int x){
        // Вызвать Member() на обоих множествах
        return null;
    }

    // Очистить множество
    public void MakeNull(){
        //Обнулить ячейки массива
        for (int i = 0; i < array.length; i++) {
            array[i] = 0;
        }
    }

    public void Print(){
        for (int i = 0; i < array.length; i++) {
//            System.out.println(toBinaryString(array[i]));
//            System.out.println(Integer.toBinaryString(i));
        }
    }
    public String toBinaryString(int value) {
        StringBuilder result = new StringBuilder(32);
        for (int i = 0; i < 32; i++) {
            System.out.print(i + " ");
        }
        System.out.println();
        for(int i = 0; i < 32; ++i) {
            if ((value & 1) == 1) {
                System.out.print("1 ");
            } else {
                System.out.print("0 ");
            }
            value >>>= 1;
        }
        return result.reverse().toString();
    }

    @Override
    public String toString() {
        return "ArraySet{" +
                "x=" + x +
                ", y=" + y +
                ", array=" + Arrays.toString(array) +
                '}';
    }
}

//пересечение
//копировать весь список и выкидывать элементы?

//тоже самое касается разности

//для пересечения обьед и разности find не нужен
//стартуем и по первому множеству и одновременно по второму
//потому что они упорядоченные

//идем последовательно до конца пока не кончится список

